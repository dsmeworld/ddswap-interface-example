{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar $schema = \"http://json-schema.org/draft-07/schema#\";\nvar $id = \"https://uniswap.org/tokenlist.schema.json\";\nvar title = \"Uniswap Token List\";\nvar description = \"Schema for lists of tokens compatible with the Uniswap Interface\";\nvar definitions = {\n  Version: {\n    type: \"object\",\n    description: \"The version of the list, used in change detection\",\n    examples: [{\n      major: 1,\n      minor: 0,\n      patch: 0\n    }],\n    additionalProperties: false,\n    properties: {\n      major: {\n        type: \"integer\",\n        description: \"The major version of the list. Must be incremented when tokens are removed from the list or token addresses are changed.\",\n        minimum: 0,\n        examples: [1, 2]\n      },\n      minor: {\n        type: \"integer\",\n        description: \"The minor version of the list. Must be incremented when tokens are added to the list.\",\n        minimum: 0,\n        examples: [0, 1]\n      },\n      patch: {\n        type: \"integer\",\n        description: \"The patch version of the list. Must be incremented for any changes to the list.\",\n        minimum: 0,\n        examples: [0, 1]\n      }\n    },\n    required: [\"major\", \"minor\", \"patch\"]\n  },\n  TagIdentifier: {\n    type: \"string\",\n    description: \"The unique identifier of a tag\",\n    minLength: 1,\n    maxLength: 10,\n    pattern: \"^[\\\\w]+$\",\n    examples: [\"compound\", \"stablecoin\"]\n  },\n  ExtensionIdentifier: {\n    type: \"string\",\n    description: \"The name of a token extension property\",\n    minLength: 1,\n    maxLength: 40,\n    pattern: \"^[\\\\w]+$\",\n    examples: [\"color\", \"is_fee_on_transfer\", \"aliases\"]\n  },\n  ExtensionMap: {\n    type: \"object\",\n    description: \"An object containing any arbitrary or vendor-specific token metadata\",\n    maxProperties: 10,\n    propertyNames: {\n      $ref: \"#/definitions/ExtensionIdentifier\"\n    },\n    additionalProperties: {\n      $ref: \"#/definitions/ExtensionValue\"\n    },\n    examples: [{\n      color: \"#000000\",\n      is_verified_by_me: true\n    }, {\n      \"x-bridged-addresses-by-chain\": {\n        \"1\": {\n          bridgeAddress: \"0x4200000000000000000000000000000000000010\",\n          tokenAddress: \"0x4200000000000000000000000000000000000010\"\n        }\n      }\n    }]\n  },\n  ExtensionPrimitiveValue: {\n    anyOf: [{\n      type: \"string\",\n      minLength: 1,\n      maxLength: 42,\n      examples: [\"#00000\"]\n    }, {\n      type: \"boolean\",\n      examples: [true]\n    }, {\n      type: \"number\",\n      examples: [15]\n    }, {\n      type: \"null\"\n    }]\n  },\n  ExtensionValue: {\n    anyOf: [{\n      $ref: \"#/definitions/ExtensionPrimitiveValue\"\n    }, {\n      type: \"object\",\n      maxProperties: 10,\n      propertyNames: {\n        $ref: \"#/definitions/ExtensionIdentifier\"\n      },\n      additionalProperties: {\n        $ref: \"#/definitions/ExtensionValueInner0\"\n      }\n    }]\n  },\n  ExtensionValueInner0: {\n    anyOf: [{\n      $ref: \"#/definitions/ExtensionPrimitiveValue\"\n    }, {\n      type: \"object\",\n      maxProperties: 10,\n      propertyNames: {\n        $ref: \"#/definitions/ExtensionIdentifier\"\n      },\n      additionalProperties: {\n        $ref: \"#/definitions/ExtensionValueInner1\"\n      }\n    }]\n  },\n  ExtensionValueInner1: {\n    anyOf: [{\n      $ref: \"#/definitions/ExtensionPrimitiveValue\"\n    }]\n  },\n  TagDefinition: {\n    type: \"object\",\n    description: \"Definition of a tag that can be associated with a token via its identifier\",\n    additionalProperties: false,\n    properties: {\n      name: {\n        type: \"string\",\n        description: \"The name of the tag\",\n        pattern: \"^[ \\\\w]+$\",\n        minLength: 1,\n        maxLength: 20\n      },\n      description: {\n        type: \"string\",\n        description: \"A user-friendly description of the tag\",\n        pattern: \"^[ \\\\w\\\\.,:]+$\",\n        minLength: 1,\n        maxLength: 200\n      }\n    },\n    required: [\"name\", \"description\"],\n    examples: [{\n      name: \"Stablecoin\",\n      description: \"A token with value pegged to another asset\"\n    }]\n  },\n  TokenInfo: {\n    type: \"object\",\n    description: \"Metadata for a single token in a token list\",\n    additionalProperties: false,\n    properties: {\n      chainId: {\n        type: \"integer\",\n        description: \"The chain ID of the Ethereum network where this token is deployed\",\n        minimum: 1,\n        examples: [1, 42]\n      },\n      address: {\n        type: \"string\",\n        description: \"The checksummed address of the token on the specified chain ID\",\n        pattern: \"^0x[a-fA-F0-9]{40}$\",\n        examples: [\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"]\n      },\n      decimals: {\n        type: \"integer\",\n        description: \"The number of decimals for the token balance\",\n        minimum: 0,\n        maximum: 255,\n        examples: [18]\n      },\n      name: {\n        type: \"string\",\n        description: \"The name of the token\",\n        minLength: 1,\n        maxLength: 40,\n        pattern: \"^[ \\\\w.'+\\\\-%/À-ÖØ-öø-ÿ:&\\\\[\\\\]\\\\(\\\\)]+$\",\n        examples: [\"USD Coin\"]\n      },\n      symbol: {\n        type: \"string\",\n        description: \"The symbol for the token; must be alphanumeric\",\n        pattern: \"^[a-zA-Z0-9+\\\\-%/$.]+$\",\n        minLength: 1,\n        maxLength: 20,\n        examples: [\"USDC\"]\n      },\n      logoURI: {\n        type: \"string\",\n        description: \"A URI to the token logo asset; if not set, interface will attempt to find a logo based on the token address; suggest SVG or PNG of size 64x64\",\n        format: \"uri\",\n        examples: [\"ipfs://QmXfzKRvjZz3u5JRgC4v5mGVbm9ahrUiB4DgzHBsnWbTMM\"]\n      },\n      tags: {\n        type: \"array\",\n        description: \"An array of tag identifiers associated with the token; tags are defined at the list level\",\n        items: {\n          $ref: \"#/definitions/TagIdentifier\"\n        },\n        maxItems: 10,\n        examples: [\"stablecoin\", \"compound\"]\n      },\n      extensions: {\n        $ref: \"#/definitions/ExtensionMap\"\n      }\n    },\n    required: [\"chainId\", \"address\", \"decimals\", \"name\", \"symbol\"]\n  }\n};\nvar type = \"object\";\nvar additionalProperties = false;\nvar properties = {\n  name: {\n    type: \"string\",\n    description: \"The name of the token list\",\n    minLength: 1,\n    maxLength: 20,\n    pattern: \"^[\\\\w ]+$\",\n    examples: [\"My Token List\"]\n  },\n  timestamp: {\n    type: \"string\",\n    format: \"date-time\",\n    description: \"The timestamp of this list version; i.e. when this immutable version of the list was created\"\n  },\n  version: {\n    $ref: \"#/definitions/Version\"\n  },\n  tokens: {\n    type: \"array\",\n    description: \"The list of tokens included in the list\",\n    items: {\n      $ref: \"#/definitions/TokenInfo\"\n    },\n    minItems: 1,\n    maxItems: 10000\n  },\n  keywords: {\n    type: \"array\",\n    description: \"Keywords associated with the contents of the list; may be used in list discoverability\",\n    items: {\n      type: \"string\",\n      description: \"A keyword to describe the contents of the list\",\n      minLength: 1,\n      maxLength: 20,\n      pattern: \"^[\\\\w ]+$\",\n      examples: [\"compound\", \"lending\", \"personal tokens\"]\n    },\n    maxItems: 20,\n    uniqueItems: true\n  },\n  tags: {\n    type: \"object\",\n    description: \"A mapping of tag identifiers to their name and description\",\n    propertyNames: {\n      $ref: \"#/definitions/TagIdentifier\"\n    },\n    additionalProperties: {\n      $ref: \"#/definitions/TagDefinition\"\n    },\n    maxProperties: 20,\n    examples: [{\n      stablecoin: {\n        name: \"Stablecoin\",\n        description: \"A token with value pegged to another asset\"\n      }\n    }]\n  },\n  logoURI: {\n    type: \"string\",\n    description: \"A URI for the logo of the token list; prefer SVG or PNG of size 256x256\",\n    format: \"uri\",\n    examples: [\"ipfs://QmXfzKRvjZz3u5JRgC4v5mGVbm9ahrUiB4DgzHBsnWbTMM\"]\n  }\n};\nvar required = [\"name\", \"timestamp\", \"version\", \"tokens\"];\nvar tokenlist_schema = {\n  $schema: $schema,\n  $id: $id,\n  title: title,\n  description: description,\n  definitions: definitions,\n  type: type,\n  additionalProperties: additionalProperties,\n  properties: properties,\n  required: required\n};\n/**\r\n * Comparator function that allows sorting version from lowest to highest\r\n * @param versionA version A to compare\r\n * @param versionB version B to compare\r\n * @returns -1 if versionA comes before versionB, 0 if versionA is equal to version B, and 1 if version A comes after version B\r\n */\n\nfunction versionComparator(versionA, versionB) {\n  if (versionA.major < versionB.major) {\n    return -1;\n  } else if (versionA.major > versionB.major) {\n    return 1;\n  } else if (versionA.minor < versionB.minor) {\n    return -1;\n  } else if (versionA.minor > versionB.minor) {\n    return 1;\n  } else if (versionA.patch < versionB.patch) {\n    return -1;\n  } else if (versionA.patch > versionB.patch) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n/**\r\n * Returns true if versionB is an update over versionA\r\n */\n\n\nfunction isVersionUpdate(base, update) {\n  return versionComparator(base, update) < 0;\n}\n\n(function (VersionUpgrade) {\n  VersionUpgrade[VersionUpgrade[\"NONE\"] = 0] = \"NONE\";\n  VersionUpgrade[VersionUpgrade[\"PATCH\"] = 1] = \"PATCH\";\n  VersionUpgrade[VersionUpgrade[\"MINOR\"] = 2] = \"MINOR\";\n  VersionUpgrade[VersionUpgrade[\"MAJOR\"] = 3] = \"MAJOR\";\n})(exports.VersionUpgrade || (exports.VersionUpgrade = {}));\n/**\r\n * Return the upgrade type from the base version to the update version.\r\n * Note that downgrades and equivalent versions are both treated as `NONE`.\r\n * @param base base list\r\n * @param update update to the list\r\n */\n\n\nfunction getVersionUpgrade(base, update) {\n  if (update.major > base.major) {\n    return exports.VersionUpgrade.MAJOR;\n  }\n\n  if (update.major < base.major) {\n    return exports.VersionUpgrade.NONE;\n  }\n\n  if (update.minor > base.minor) {\n    return exports.VersionUpgrade.MINOR;\n  }\n\n  if (update.minor < base.minor) {\n    return exports.VersionUpgrade.NONE;\n  }\n\n  return update.patch > base.patch ? exports.VersionUpgrade.PATCH : exports.VersionUpgrade.NONE;\n}\n/**\r\n * compares two token info key values\r\n * this subset of full deep equal functionality does not work on objects or object arrays\r\n * @param a comparison item a\r\n * @param b comparison item b\r\n */\n\n\nfunction compareTokenInfoProperty(a, b) {\n  if (a === b) return true;\n  if (typeof a !== typeof b) return false;\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.every(function (el, i) {\n      return b[i] === el;\n    });\n  }\n\n  return false;\n}\n/**\r\n * Computes the diff of a token list where the first argument is the base and the second argument is the updated list.\r\n * @param base base list\r\n * @param update updated list\r\n */\n\n\nfunction diffTokenLists(base, update) {\n  var indexedBase = base.reduce(function (memo, tokenInfo) {\n    if (!memo[tokenInfo.chainId]) memo[tokenInfo.chainId] = {};\n    memo[tokenInfo.chainId][tokenInfo.address] = tokenInfo;\n    return memo;\n  }, {});\n  var newListUpdates = update.reduce(function (memo, tokenInfo) {\n    var _indexedBase$tokenInf;\n\n    var baseToken = (_indexedBase$tokenInf = indexedBase[tokenInfo.chainId]) == null ? void 0 : _indexedBase$tokenInf[tokenInfo.address];\n\n    if (!baseToken) {\n      memo.added.push(tokenInfo);\n    } else {\n      var changes = Object.keys(tokenInfo).filter(function (s) {\n        return s !== 'address' && s !== 'chainId';\n      }).filter(function (s) {\n        return !compareTokenInfoProperty(tokenInfo[s], baseToken[s]);\n      });\n\n      if (changes.length > 0) {\n        if (!memo.changed[tokenInfo.chainId]) {\n          memo.changed[tokenInfo.chainId] = {};\n        }\n\n        memo.changed[tokenInfo.chainId][tokenInfo.address] = changes;\n      }\n    }\n\n    if (!memo.index[tokenInfo.chainId]) {\n      var _memo$index$tokenInfo;\n\n      memo.index[tokenInfo.chainId] = (_memo$index$tokenInfo = {}, _memo$index$tokenInfo[tokenInfo.address] = true, _memo$index$tokenInfo);\n    } else {\n      memo.index[tokenInfo.chainId][tokenInfo.address] = true;\n    }\n\n    return memo;\n  }, {\n    added: [],\n    changed: {},\n    index: {}\n  });\n  var removed = base.reduce(function (list, curr) {\n    if (!newListUpdates.index[curr.chainId] || !newListUpdates.index[curr.chainId][curr.address]) {\n      list.push(curr);\n    }\n\n    return list;\n  }, []);\n  return {\n    added: newListUpdates.added,\n    changed: newListUpdates.changed,\n    removed: removed\n  };\n}\n/**\r\n * Returns the minimum version bump for the given list\r\n * @param baseList the base list of tokens\r\n * @param updatedList the updated list of tokens\r\n */\n\n\nfunction minVersionBump(baseList, updatedList) {\n  var diff = diffTokenLists(baseList, updatedList);\n  if (diff.removed.length > 0) return exports.VersionUpgrade.MAJOR;\n  if (diff.added.length > 0) return exports.VersionUpgrade.MINOR;\n  if (Object.keys(diff.changed).length > 0) return exports.VersionUpgrade.PATCH;\n  return exports.VersionUpgrade.NONE;\n}\n/**\r\n * Returns the next version of the list given a base version and the upgrade type\r\n * @param base current version\r\n * @param bump the upgrade type\r\n */\n\n\nfunction nextVersion(base, bump) {\n  switch (bump) {\n    case exports.VersionUpgrade.NONE:\n      return base;\n\n    case exports.VersionUpgrade.MAJOR:\n      return {\n        major: base.major + 1,\n        minor: 0,\n        patch: 0\n      };\n\n    case exports.VersionUpgrade.MINOR:\n      return {\n        major: base.major,\n        minor: base.minor + 1,\n        patch: 0\n      };\n\n    case exports.VersionUpgrade.PATCH:\n      return {\n        major: base.major,\n        minor: base.minor,\n        patch: base.patch + 1\n      };\n  }\n}\n\nexports.diffTokenLists = diffTokenLists;\nexports.getVersionUpgrade = getVersionUpgrade;\nexports.isVersionUpdate = isVersionUpdate;\nexports.minVersionBump = minVersionBump;\nexports.nextVersion = nextVersion;\nexports.schema = tokenlist_schema;\nexports.versionComparator = versionComparator;","map":{"version":3,"sources":["../src/versionComparator.ts","../src/isVersionUpdate.ts","../src/getVersionUpgrade.ts","../src/diffTokenLists.ts","../src/minVersionBump.ts","../src/nextVersion.ts"],"names":["versionComparator","versionA","versionB","isVersionUpdate","base","update","VersionUpgrade","getVersionUpgrade","a","Array","b","diffTokenLists","indexedBase","memo","tokenInfo","newListUpdates","baseToken","changes","s","compareTokenInfoProperty","added","changed","index","removed","curr","list","minVersionBump","baseList","updatedList","diff","Object","nextVersion","bump","major","minor","patch"],"mappings":"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","sourcesContent":["import { Version } from './types';\r\n\r\n/**\r\n * Comparator function that allows sorting version from lowest to highest\r\n * @param versionA version A to compare\r\n * @param versionB version B to compare\r\n * @returns -1 if versionA comes before versionB, 0 if versionA is equal to version B, and 1 if version A comes after version B\r\n */\r\nexport function versionComparator(\r\n  versionA: Version,\r\n  versionB: Version\r\n): -1 | 0 | 1 {\r\n  if (versionA.major < versionB.major) {\r\n    return -1;\r\n  } else if (versionA.major > versionB.major) {\r\n    return 1;\r\n  } else if (versionA.minor < versionB.minor) {\r\n    return -1;\r\n  } else if (versionA.minor > versionB.minor) {\r\n    return 1;\r\n  } else if (versionA.patch < versionB.patch) {\r\n    return -1;\r\n  } else if (versionA.patch > versionB.patch) {\r\n    return 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n","import { versionComparator } from './versionComparator';\r\nimport { Version } from './types';\r\n\r\n/**\r\n * Returns true if versionB is an update over versionA\r\n */\r\nexport function isVersionUpdate(base: Version, update: Version): boolean {\r\n  return versionComparator(base, update) < 0;\r\n}\r\n","/**\r\n * Enum describing types of version differences\r\n */\r\nimport { Version } from './types';\r\n\r\nexport enum VersionUpgrade {\r\n  NONE,\r\n  PATCH,\r\n  MINOR,\r\n  MAJOR,\r\n}\r\n\r\n/**\r\n * Return the upgrade type from the base version to the update version.\r\n * Note that downgrades and equivalent versions are both treated as `NONE`.\r\n * @param base base list\r\n * @param update update to the list\r\n */\r\nexport function getVersionUpgrade(\r\n  base: Version,\r\n  update: Version\r\n): VersionUpgrade {\r\n  if (update.major > base.major) {\r\n    return VersionUpgrade.MAJOR;\r\n  }\r\n  if (update.major < base.major) {\r\n    return VersionUpgrade.NONE;\r\n  }\r\n  if (update.minor > base.minor) {\r\n    return VersionUpgrade.MINOR;\r\n  }\r\n  if (update.minor < base.minor) {\r\n    return VersionUpgrade.NONE;\r\n  }\r\n  return update.patch > base.patch ? VersionUpgrade.PATCH : VersionUpgrade.NONE;\r\n}\r\n","import { TokenInfo } from './types';\r\n\r\nexport type TokenInfoChangeKey = Exclude<\r\n  keyof TokenInfo,\r\n  'address' | 'chainId'\r\n>;\r\nexport type TokenInfoChanges = Array<TokenInfoChangeKey>;\r\n\r\n/**\r\n * compares two token info key values\r\n * this subset of full deep equal functionality does not work on objects or object arrays\r\n * @param a comparison item a\r\n * @param b comparison item b\r\n */\r\nfunction compareTokenInfoProperty(a: unknown, b: unknown): boolean {\r\n  if (a === b) return true;\r\n  if (typeof a !== typeof b) return false;\r\n  if (Array.isArray(a) && Array.isArray(b)) {\r\n    return a.every((el, i) => b[i] === el);\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Differences between a base list and an updated list.\r\n */\r\nexport interface TokenListDiff {\r\n  /**\r\n   * Tokens from updated with chainId/address not present in base list\r\n   */\r\n  readonly added: TokenInfo[];\r\n  /**\r\n   * Tokens from base with chainId/address not present in the updated list\r\n   */\r\n  readonly removed: TokenInfo[];\r\n  /**\r\n   * The token info that changed\r\n   */\r\n  readonly changed: {\r\n    [chainId: number]: {\r\n      [address: string]: TokenInfoChanges;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Computes the diff of a token list where the first argument is the base and the second argument is the updated list.\r\n * @param base base list\r\n * @param update updated list\r\n */\r\nexport function diffTokenLists(\r\n  base: TokenInfo[],\r\n  update: TokenInfo[]\r\n): TokenListDiff {\r\n  const indexedBase = base.reduce<{\r\n    [chainId: number]: { [address: string]: TokenInfo };\r\n  }>((memo, tokenInfo) => {\r\n    if (!memo[tokenInfo.chainId]) memo[tokenInfo.chainId] = {};\r\n    memo[tokenInfo.chainId][tokenInfo.address] = tokenInfo;\r\n    return memo;\r\n  }, {});\r\n\r\n  const newListUpdates = update.reduce<{\r\n    added: TokenInfo[];\r\n    changed: {\r\n      [chainId: number]: {\r\n        [address: string]: TokenInfoChanges;\r\n      };\r\n    };\r\n    index: {\r\n      [chainId: number]: {\r\n        [address: string]: true;\r\n      };\r\n    };\r\n  }>(\r\n    (memo, tokenInfo) => {\r\n      const baseToken = indexedBase[tokenInfo.chainId]?.[tokenInfo.address];\r\n      if (!baseToken) {\r\n        memo.added.push(tokenInfo);\r\n      } else {\r\n        const changes: TokenInfoChanges = Object.keys(tokenInfo)\r\n          .filter(\r\n            (s): s is TokenInfoChangeKey => s !== 'address' && s !== 'chainId'\r\n          )\r\n          .filter(s => {\r\n            return !compareTokenInfoProperty(tokenInfo[s], baseToken[s]);\r\n          });\r\n        if (changes.length > 0) {\r\n          if (!memo.changed[tokenInfo.chainId]) {\r\n            memo.changed[tokenInfo.chainId] = {};\r\n          }\r\n          memo.changed[tokenInfo.chainId][tokenInfo.address] = changes;\r\n        }\r\n      }\r\n\r\n      if (!memo.index[tokenInfo.chainId]) {\r\n        memo.index[tokenInfo.chainId] = {\r\n          [tokenInfo.address]: true,\r\n        };\r\n      } else {\r\n        memo.index[tokenInfo.chainId][tokenInfo.address] = true;\r\n      }\r\n\r\n      return memo;\r\n    },\r\n    { added: [], changed: {}, index: {} }\r\n  );\r\n\r\n  const removed = base.reduce<TokenInfo[]>((list, curr) => {\r\n    if (\r\n      !newListUpdates.index[curr.chainId] ||\r\n      !newListUpdates.index[curr.chainId][curr.address]\r\n    ) {\r\n      list.push(curr);\r\n    }\r\n    return list;\r\n  }, []);\r\n\r\n  return {\r\n    added: newListUpdates.added,\r\n    changed: newListUpdates.changed,\r\n    removed,\r\n  };\r\n}\r\n","import { diffTokenLists } from './diffTokenLists';\r\nimport { VersionUpgrade } from './getVersionUpgrade';\r\nimport { TokenInfo } from './types';\r\n\r\n/**\r\n * Returns the minimum version bump for the given list\r\n * @param baseList the base list of tokens\r\n * @param updatedList the updated list of tokens\r\n */\r\nexport function minVersionBump(\r\n  baseList: TokenInfo[],\r\n  updatedList: TokenInfo[]\r\n): VersionUpgrade {\r\n  const diff = diffTokenLists(baseList, updatedList);\r\n  if (diff.removed.length > 0) return VersionUpgrade.MAJOR;\r\n  if (diff.added.length > 0) return VersionUpgrade.MINOR;\r\n  if (Object.keys(diff.changed).length > 0) return VersionUpgrade.PATCH;\r\n  return VersionUpgrade.NONE;\r\n}\r\n","import { VersionUpgrade } from './getVersionUpgrade';\r\nimport { Version } from './types';\r\n\r\n/**\r\n * Returns the next version of the list given a base version and the upgrade type\r\n * @param base current version\r\n * @param bump the upgrade type\r\n */\r\nexport function nextVersion(base: Version, bump: VersionUpgrade): Version {\r\n  switch (bump) {\r\n    case VersionUpgrade.NONE:\r\n      return base;\r\n\r\n    case VersionUpgrade.MAJOR:\r\n      return { major: base.major + 1, minor: 0, patch: 0 };\r\n\r\n    case VersionUpgrade.MINOR:\r\n      return {\r\n        major: base.major,\r\n        minor: base.minor + 1,\r\n        patch: 0,\r\n      };\r\n\r\n    case VersionUpgrade.PATCH:\r\n      return {\r\n        major: base.major,\r\n        minor: base.minor,\r\n        patch: base.patch + 1,\r\n      };\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}